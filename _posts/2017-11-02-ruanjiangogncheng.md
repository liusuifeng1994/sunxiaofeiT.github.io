---
layout: blog
istop: true
isLast: true
code: true
title: "软件工程中的概念、相关知识点总结"
background-image: "../img/2017-11-02-2.jpg"
date: 2017-11-02 19:00:00
category: 软件工程 
tags: 
- 软件工程
- 软件工程学科概念
- 软件工程相关知识点
- 传统软件工程
---

# 传统软件工程学科中的概念、相关知识点总结

## 1、软件与软件工程

### 1.1 软件的概念、软件的特点、软件发展的四个阶段

#### 软件的概念
- 软件是计算机系统的重要组成部分；
- 软件是逻辑产品，需要计算机硬件和系统软件的支撑；
- 软件是计算机控制系统的指挥中枢；
- 软件是信息转换器，它能对信息进行加工、处理或变换；
- 软件是工具，在人们的生活、工作、休闲，在社会的经济、军事、政治、文化、科学技术、教育中发挥具大作用

> 软件是能够完成预定功能和性能，并对相应数据进行加工的程序和描述程序及其操作的文档。  
> 软件 = 程序+数据+文档  
> 程序 = 算法+数据结构

#### 软件的特点

- 软件是被开发或设计的,而不是传统意义上被制造的
- 软件不会”磨损”
- 软件产业逐步走向基于构件的组装,但还是定制的

#### 软件发展的四个阶段
- 1950---1965,没有系统的软件开发方法和管理机制、自定义软件、批处理、有限分布。
- 1965---1975,产生人机交互的新概念、新技术软件产品、多用户、实时、数据库。
- 1973---1988,微处理器的出现并广泛应用,分布式系统、嵌入智能、低成本硬件、消费者的影响。
- 1986---2000,广域和局域网络迅速普及,强大的桌面系统、面向对象技术、专家系统、人工智能、神经网络、并行计算、网络计算机。

### 1.2 软件危机产生的原因，解决软件危机的方法

#### 软件危机产生的原因

- 软件的规模加大、复杂性提高、性能增强
- 软件是逻辑产品, 尚未完全认识其本质和特点
- 缺乏有效的、系统的开发、维护大型软件项目的技术手段和管理方法
- 用户对软件需求的描述和软件开发人员对需求的理解往往存在差异，用户经常要求修改需求，开发人员很难适应
- 软件开发的技术人员和管理人员缺乏软件工程化的素质和要求，对工程化的开销认识不足

#### 解决软件危机的办法

- 

### 1.3 软件工程的概念，软件工程的三要素

#### 软件工程的概念

- 软件工程 Fritz Bauer[nau69]：为了经济的获得可靠的，在实际机器上高效运行的软件，而建立和使用的好的工程原则。
- 软件工程 [ 教材]：软件工程是运用工程、科学和数学的原则与方法研制、维护计算机软件的有关技术和管理的方法。
- 软件工程[IEEE93]：将系统的、规范的、可度量的方法应用于软件的开发、运行和维护的过程。

#### 软件工程的三要素

过程、工具、方法

### 1.4 软件生命周期个阶段及其基本任务

- 软件定义  
    - 问题定义：确定系统的总体目标
    - 可行性分析：研究经济、技术、操作等的可信性
    - 需求分析：收集需求，需求建模
- 软件开发  
    - 系统设计：软件结构设计、数据设计、接口设计和过程设计
    - 编码：产生源程序清单
    - 测试： 产生软件测试计划和软件测试报告  
- 软件运行  
    - 维护：修改、完善、扩展软件

### 1.5 软件开发过程模型：瀑布模型、原型模型、螺旋模型等几种模型的形式与特点及使用范围

#### 瀑布模型

- 主要思想：  

软件开发过程与软件生命周期是一致的  
相邻二阶段之间存在因果关系  
需对阶段性产品进行评审  

- 示意图：
![img](/img/2017-11-02-2-1.jpg)

- 瀑布模型的优点：  
软件生命周期模型，使软件开发过程可以再分心、设计、编码、测试和维护的框架下进行  
软件开发过程具有系统性、可控性，客服了软件开发的随意性  

- 瀑布模型的缺点：  
项目开始阶段很难精确提出产品需求，由于技术进步，用户对系统深入的理解，修改需求十分普遍  
项目开发晚期才能的带程序的运行版本，这是修稿软件需求和开发中的错误代价很大  
采用线性模型组织项目开发经常发生开发小组人员“堵塞状态”，特别是项目的开始和结束  

#### 原型模型

- 原型模型示意图
![img](/img/yuanxing.png) 

- 优点：  
原型模型支持软件需求开发，帮助用户和开发人员理解需求，使软件需求工程的关键  
它产生的正式需求文档，是软件开发的基础  
如果开发的原型是可运行的，它的若干高质量的程序片段和开发工具可用于工作程序的开发  
原型的开发和评审时系统分析员和用户/客户共同参与的迭代过程，每个迭代循环都是线性过程  

- 缺点：  
对于大型软件项目，RAD模型需要足够的人力资源已建立足够的原型组  
RAD模型要求开发者和客户再一段时间内共同完成原型系统的开发，如果任何一方没有实现承诺，会导致原型开发的失败  
如果系统难以模块化，建造RAD模型所需构建就有问题，如果高性能是一个指标，RAD模型也可能不奏效  
RAD模型不适合采用很多新技术的项目  

- RAD模型的开发过程：  
业务建模-> 数据建模->过程建模->应用生成->测试修正

#### 螺旋模型

- 螺旋模型=线性模型+迭代，原型+系统化  
螺旋模型适用于计算机软件整个生命周期  

- 示意图 ![img](/img/2017-11-02-2-3.jpg)

- 示意图 ![img](/img/2017-11-02-2-4.jpg)  

- 优点：   
符合人们认识现实世界和软件开发的客覌规律；  
支持软件整个生命周期；  
保持瀑布模型的系统性、阶段性；  
利用原型评估降低开发风险；  
开发者和用户共同参与软件开发，尽早发现软件中的错误；  
不断推出和完善软件版本，有助于需求变化，获取用户需求，加强对需求的理解。  

#### 增量模型

- 小而可用的软件  

- 特点：  
在前面增量的基础上开发后面的增量  
每个增量的开发可用瀑布或快速原型模型  
迭代的思路  

#### 并发开发模型

- 示意图：  ![img](/img/2017-11-02-2-5.jpg)

#### 形式化开发方法

- 用严格的、数学的符号体系来规约、开发和验证基于计算机的系统。
解决软件开发过程使用其它范型难以克服的二义性、不完整性和不一致性。
可以产生无缺陷软件的承诺。
费时、昂贵、难沟通，需要培训
是建造重要的、安全的软件的开发者可以考虑开发范型。比如：航空电子、医疗设备软件的开发。

## 2 软件项目管理

### 2.1软件项目管理的基本概念

软件项目管理 
- 人员管理  
    - 项目参与者
    - 项目负责人呢
    - 软件项目组
    - 协调通信问题
- 产品管理  
    - 软件范围
    - 问题分解
- 过程管理  
    - 确定软件过程模型
    - 过程分解
- 项目管理  
    - 确定危险信息
    - 确定解决方案

### 2.2 软件项目估算（代码行、功能点估算）

#### 2.2.1 度量 metrics 

度量具有数字特征，软件工程范围的度量是软件开发过程、软件资源或软件产品简单属性的定量描述。  
如，程序规模、操作符个数、程序中错误的个数等

#### 2.2.2 估算 estimation  

对软件产品、过程、资源进行预测  
估算可以采用经验公式、或参考历史资料  
估算用于事前签订合同、立项、制定工作计划等  

#### 2.2.3 面向规模的度量

- 代码行数 LOC或 KLOC
- 生产率 p1 = L/E，其中，L软件项目代码行数，E软件项目工作量，P1软件项目生产率（LOC/PM）
- 代码出错率： EQR1 = Ne/L，其中，Ne软件项目的代码错误数，EQR1每千行代码的错误数。
- 每行代码的平均成本，CI=S/L，其中S为软件项目总开销，CI为软件项目每行代码的平均成本。
- 文档与代码比，DI=Pd/L，其中，Pd软件项目文档页数，DI每千行代码的平均文档数。
- M 为人数，PM 为工作量

##### 2.2.3.1 规模度量的优缺点

- 优点：
    - 用软件代码行数估算软件规模简单易行。
- 缺点：
    - 代码行数的估算依赖于程序设计语言的功能和表达能力
    - 采用代码行估算方法会对设计精巧的软件项目产生不利的影响
    - 在软件项目开发前或开发初期估算它的代码行数十分困难
    - 代码行估算只适用于过程式程序设计语言，对非过程式的程序设计语言不太适用等等。

#### 2.2.4 面向功能的度量

2.2.4.1 根据事务信息处理程序的基本功能定义的，在系统设计初期可以估算出软件项目的规模：  
FP=CT* ［0.65+0.01*∑Fi ］
其中：CT 按表3.1 计算()，Fi 是复杂性调节值，Fi值取值 0,1,...,5，当Fi = 0时，表示 Fi 不起作用，Fi = 5时，表示 Fi 作用最大。 

一些符号代表的意思：  
- 用户输入数，用户为软件提供的输入参数的个数
- 用户输出数，软件系统为用户提供的输出参数个数
- 用户查询数，哟个练级输入确定一次查询，软件以联机输出的形式，实时的产生一个响应。
- 文件数，统计逻辑的主文件个数
- 外部界面数，统计所有机器可读的界面，利用这些界面可以将信息从一个系统传送到另一个系统。

计算方法：　　
- 生产率： Pf=FP/E，其中，Pf表示每人月完成的功能点数。
- 平均成本：Ci=S/FP，其中，Ci表示每功能点的平均成本。
- 文档用与功能点比：Di=Pd/FP，其中，Di表示每个功能点平均具有的文档页数。
- 代码出错率： EORi = Ne/FP，其中，EORi表示每个功能点的平均错误个数。

简单功能点与功能点：  
- FPs，简单功能点。
- FP，功能点，引入了算法复杂性因素。

优缺点：  
- 优点：
    - 与程序设计语言无关 ， 它不仅适用于过程式语言 ， 也适用于非过程式的语言。
    - 软件项目开发初期就能基本上确定系统的输入 、输出等参数 ， 功能点度量能用于软件项目的开发初期
- 缺点：
    - 它涉及到的主观因素比较多 ， 如各种权函数的取值
    - 信息领域中的某些数据有时不容易采集
    - FP 的值没有直观的物理意义

#### 2.2.5 代码行度量与功能点度量的比较

- 代码行度量依赖于程序设计语言， 而功能点度量不依赖于程序设计语言
- Albrecht 和Jones 等人对若干软件采用事后处理的方式分别统计出不同程序设计语言每个功能点与代码行数的关系 ，用 用LOC/FP 的平均值表示。
- ，行 一行Ada 语言代码的 “ 功能 ” 平均行是一行FORTRAN 语言代码 “ 功能 ”的1.4倍，一行四代语言代码的 “ 功能 ” 平均是一行传统程序设计语言代码 “ 功能 ”的3至5倍

#### 2.2.6 各种语言的LOC/FP（平均值）

汇编语言 300，
COBOL 100，
FORTRAN 100，
Pascal 90，
Ada 70，
面向对象的语言 30，
四代语言(4GL) 20，
代码生成器 15，

### 2.3 McCabe度量法，能完成环路复杂度的度量

#### 2.3.1 定义
McCabe 度量法又称环路复杂性度量，基于程序控制结构的软件复杂性度量模型。

#### 2.3.2 程序控制结构图

- 程序结构对应于有一个入口结点和一个出口结点的有向图
- 途中每个结点对应一个语句或一个顺序流程的程序代码块
- 弧对应于程序中的转移
- 它基于一个程序模块的程序图中环路的个数，因此计算它先要画出程序图。
- 程序图是退化的程序流程图，流程图中每个处理都退化成一个结点，流线变成链接不同结点的有向弧。

#### 2.3.3 McCabe 度量法

McCabe 用程序控制结构图的巡回秩数V（G）作为程序结构复杂性的度量  
V(G) = e-n+2  
其中，e为结构图的边数，n为结构图的结点数  
可以证明V(G) 等于结构图中有界或无界的封闭区域个数。
  
V(G)的值不要大于10，当V(G)>10时，模块内部结构就会变得复杂，给编码和测试带来困难。

#### 2.3.4 McCabe 度量的缺点

- 对于不同种类的控制流的复杂性不能区分
- 简单IF语句与循环语句的复杂性同等看待
- 嵌套IF语句与简单CASE语句的复杂性是一样的
- 木块间借口当成一个简单分支一样处理
- 一个具有1000行的顺序程序与一行语句的复杂性相同

### 2.4 成本估算方法及其特点

估算可以采用经验公式、或参考历史资料  
估算用于事前签订合同、立项、制定工作计划等
  
常用的估算方法：
- 参照已经完成的类似项目估算待开发项目的成本和工作量。
- 将大的项目分解为若干个子项目，在估算出每个子项目成本和工作量之后，再估算整个项目。
- 将软件项目按软件生存周期分解，分别估算出软件项目在软件开发各个阶段的工作量和成本，然后再把这些工作量和成本汇总估算整个项目。
- 根据试验或历史数据给出软件项目工作量或成本的经验估算公式。

> 四种方法可以同时、单独或组合使用，以便取长补短，提高项目估算的精度和可靠性。采用分解技术辐射那软件项目应考虑系统集成是需要的工作量。为了实现呢软件项目估算，实践中开发了大量的软件项目自动估算工具，用以支持软件工作量或成本估算。

#### 2.4.1 分解技术

采用“分而治之”的策略就行软件项目估算。将项目分解为若干个主要的功能及相关的软件工程活动，通过逐步求精的方式进行成本及工作量估算。

#### 2.4.3 经验估算模型

可用于补充分解技术

##### 2.4.3.1 CoCoMo模型

- 计算机软件的估算模型是根据以前完成项目的实际数据导出的，用于软件项目的计划阶段。
- 模型是根据“从前的”，“局部的”数据得出的，估算模型不可能完全适用于当前所有软件项目和全部开发环境。这些模型的计算结果仅供参考。
- 两个常用的估算模型有：
    - CoCoMo模型（构造性成本模型）：1.实在静态、单变量模型的基础上构造出来的。2.分为基本、中间、详细三个层次，分别用于软件开发的三个不同阶段。3.基本CoCoMo模型，永固系统开发的初期，估算整个系统的工作量（包括软件维护）和软件开发所需要的时间。4.中间的CoCoMo模型，用于估算各个子系统的工作量和开发时间。5.详细的CoCoMo模型，用于估算独立的软部件，如子系统内部的各个模块。第三章，48页。
    - 经验估算模型，Putnam模型。1.是一个动态多变量模型，适用于软件开发的各个阶段，估算模型以大型软件项目的实测数据为基础，导出工作量分布曲线。2.它描述了开发工作量，开发时间和软件代码行数之间的关系。3.方程：第三章，61页。4.CK=2000：比较差的软件开发环境，8000一般的软件开发环境，11000比较好的软件开发环境。

#### 2.4.4 自动估算工具

实现一种或多种分解技术或经验魔性，与人机交互结合，自动估算将是很好的选择。

### 2.5 关键路径法

### 2.6 CMM与CMMI的基本概念

## 3 需求分析

### 3.1 软件需求内同

用户对目标软件系统在功能、行为、性能、设计、约束等方面的期望。  
需求分析阶段的任务，通过对问题及环境的理解、分析，将用户需求精确化，完全化，最终形成需求规格说明，描述系统信息、功能和行为。

#### 3.1.1 用户需求

用自然语言和图标描述，说明系统必须提供哪些服务、系统运行要受哪些约束

#### 3.1.2  系统需求

详细说明系统将要提供的服务以及系统受到的约束，精确的描述软件的功能，系统买方和软件开发者签订合同的重要性。

#### 3.1.3 软件设计描述

在系统需求的基础上，加入更详细的内容，构成软件设计活动的概要描述，是软件设计和实现的基础。

#### 3.1.4 需求分析的三个阶段

问题分析，需求描述，需求评审

### 3.2 需求分析常用技术

#### 3.2.1 初步需求获取技术

- 访谈与会议  
分析人员应精心准备问题，通过用户对问题的回答，逐步理解用户对目标软件的要求。（1）循序渐进，首先关心一般性，整体性问题，然后再谈论细节问题。（2）客观、公正，不应限制用户在回答问题过程中的自由发挥。（3）总结，问题汇总后应能反映软件或其子系统的全貌，能覆盖用户对目标软件或其子系统在功能、行为、性能诸方面的要求。
- 考察用户软件或其子系统业务流程
学习用户的有关业务知识，在用户帮助下了解用户的软件或子系统业务流程，结合软件开发和应用的经验提出新的用户需求。
- 联合小组
建立软件开发方和用户方共同组成的联合小组，小组成员对分析负有相同的责任。联合小组要制定自己的工作制度和计划，确定专门的记录员，另设专人负责会议的议程和资料的综合整理。选择易于理解、比较简介、精确的表示机制作为描述语言，如辅以文字说明的流程图。

#### 3.2.2 需求建模技术

- 目标软件系统的模型用来刻画系统所涉及的信息、处理功能及系统运行时的外部行为。
- 模型不应设计软件实现细节
- 选择图形符号表示信息流、处理功能及系统行为，以此来描述软件需求模型。

#### 3.2.3 快速原型技术

软件开发早期，快速建立目标软件系统原型 ，让用户对原型进行评估并提出意见 。 原型几经改进最终确定 ， 设计和编码人员遵循原型确立的外部特征实现软件产品 。如果软件产品含有大量人机交互 、 可视输出 、或者涉及复杂的算法 ， 应采用快速原型技术 。对于复杂问题, 可对某些子问题 ， 尤其是用户界面 ， 使用快速原型技术 。

#### 3.2.4 问题抽象

抽象：关注一般问题的解决途径 ， 以此指导特殊问题的求解 。 注意用户描述的抽象级别 ， 统一规划系统
行为 。避免不一致性 ， 减少分析的工作量 。

#### 3.2.5 问题分级与多视点分析

分解：根据问题的规模和复杂性进行分解 ， 并对子问题展开进一步的分析 。逐级分解 ， 直至子问题的规模降至合适程度 。在问题分解过程中 ， 要建立子问题之间的相互联系 。必须遵循子问题内部紧藕合 ， 子问题之间松藕合的原则

视点分解法：在分析的初期 ， 整体地把握一个大型问题的软件需求是困难的 。 需要从各个角度分别对问题进行理解和分析 ， 然后再综合 ， 达到全面理解的目

### 3.3 结构化分析方法

需求分析视点：系统观点，用户观点，信息观点功能观点，行为观点等 。整理 、 综合用户描述 ， 应注意用户视点的变化 ，避免遗漏

### 3.4 数据流图（DFD）的作用，能用数据流图完成需求分析，能废除精化数据流图，数据字典

第四章，第45页

## 4 软件设计基础

### 4.1 设计阶段主要任务

### 4.2 软件设计准则（抽象、信息隐蔽、模块化、自顶向下逐步求精等）

### 4.3 高内聚低耦合度的含义

### 4.4 熟悉中变换分析和事务分析，能用两种方法分析和构建软件乘此结构图

### 4.5 详细设计工具（程序流程图、盒图（N-S图）与PAD图之间的转化，能将伪码或程序转换成程序流程图、盒图（N-S图）与PAD图

## 8 软件测试

### 8.1 软件测试的目的和原则，软件测试流程

### 8.2 软件测试计划

### 8.3 软件测试技术（白盒测试、黑盒测试、利用软件测试技术进行软件测试、设计测试用例）

### 8.4 软件测试策略（单元测试、集成测试、确认测试、验收测试、系统测试）的基本概念

## 10 软件维护

### 10.1 四种维护的类型，软件维护的概念、软件可维护性

### 10.1.1 四种维护

- 改正性维护  
在软件交付使用后，因开发时测试的 不彻底 、 不完全 ，必然会有部分隐藏的错误遗留到运行阶段。这些隐藏下来的错误在某些特定的使用环境下就会暴露出来。为了识别和纠正软件错误、改正软件性能上的缺陷、排除实施中的误使用，应当进行的诊断和改正错误的过程就叫做改正性。
- 适应性维护  
在使用过程中，外部环境（新的硬、软件配置），数据环境（数据库、数据格式、数据输入、输出方式、数据存储介质）可能发生变化，卫视软件适应这种变化，而去修改软件的过程就叫做适应性维护。
- 完善性维护  
在软件的使用过程中，用户往往会对软件提出新的功能与性能的要求，为了满足这些要求，需要修改或再开发软件，以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性。
- 预防性维护  
预防性维护是为了提高软件的可维护性、可靠性等，为以后的进一步改进软件打下良好基础。预防性维护定义为：采用现金的软件工程方法对需要维护的软件或软件中的某一部分（重新）进行设计、编制和测试。

### 10.1.2 软件维护的概念

在软件运行。维护阶段软件产品进行的修改就是所谓的维护。

### 10.2 软件维护的技术有那几种

#### 10.2.1 改正性维护

通过使用新技术，大大减少进行改正性维护的需要。这些技术包括：数据库管理系统、软件开发环境、程序自动生成系统、较高级（第四代）的语言，以及新的开发方法、软件复用、防错程序设计及周期性维护审查等。

#### 10.2.2 适应性维护

这一类维护不可避免，可以控制。
- 在配置管理时，把硬件、操作系统和其他相关环境因素的可能变化考虑在内。
- 把与硬件、操作系统，以及其他外围设备有关的程序归到特定程序模块中
- 使用内部程序列表、外部文件，以及处理的例行程序包，可谓维护时修改程序提供方便。

#### 10.2.3 完善性维护

利用前两类维护中列举的方法也可以减少这一类维护。特别是数据库管理系统、程序生成器、应用软件包，可减少维护工作量，此外，建立软件系统的原型，把它在实际系统开发之前提供给用户。用户通过研究原型，进一步完善他们的功能要求，就可以减少以后完善性维护的需要。

### 10.3 维护工作量的模型

M = p + Ke的c-d次方  

M 是维护中消耗总工作量，p是上面描述的生产性工作量（如分析和评价、设计修改和实现），k是一个经验常数，c是因缺乏好的设计和文档而导致复杂性的度量，d是对软件熟悉程度的度量。

### 10.4 软件可维护性

软件可维护性的定义：
- 软件可维护性是指纠正软件系统出现的错误和缺陷，以及为满足新的要求进行修改、扩充或压缩的容易程度。
- 可维护性、可使用性、可靠性是衡量软件质量的主要质量特征。
- 软件的可维护性是软件开发阶段各个时期的关键目标。

#### 10.4.1 衡量程序的可维护性

可理解性、可使用性、可测试性、可移植性、可修改性、效率、可靠性

- 可理解性  
表明人们通过阅读源代码和相关文档，了解程序功能机器如何运行的容易程度。

#### 10.4.2 定量度量可维护性

- 质量检查表  
用于测试程序中某些质量特征是否存在的一个问题清单，质量测试与质量标准则用于定量分析和评价程序的质量。要考虑几种不同的度量标准。
- 质量测试  

- 质量标准

### 10.5 提高可维护性的方法

- 建立明确的软件质量目标和优先级
- 使用提高软件质量的技术和工具
- 进行明确的质量保证审查
- 选择可维护的程序设计语言
- 改进程序的文档


```
考试常见题型（天大）
一、名词解释（4分*5）
二、简答 （6分*5）
三、设计题（15分*2）
四、建模（10分*2）

建模要求将给出的问题陈述进行分析，做出数据流图，并完成软件层次结构图，或者将给出的数据流程图直接转化为软件层次结构图。
```


